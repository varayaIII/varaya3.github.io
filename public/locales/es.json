{
  "nav_home": "Inicio",
  "nav_about": "Sobre mí",
  "nav_projects": "Proyectos",
  "nav_blog": "Blog",
  "nav_contact": "Contacto",
  "hero_title": "Víctor Araya",
  "hero_subtitle": "Ingeniero DevOps",
  "hero_description": "Construyendo sistemas fiables y escalables a través de la automatización, la infraestructura como código y la cultura colaborativa.",
  "projects_title": "Proyectos Destacados",
  "blog_title": "Últimas Publicaciones",
  "contact_title": "Contacto",
  "project_cicd_title": "Pipeline CI/CD con GitHub Actions",
  "project_cicd_desc": "Automatiza el despliegue de este portafolio mediante un pipeline de CI/CD con GitHub Actions.",
  "project_security_title": "Seguridad Automatizada (DevSecOps)",
  "project_security_desc": "Integra escaneo de vulnerabilidades y secretos en el pipeline para asegurar el código y los contenedores.",
  "project_iac_title": "Infraestructura como Código",
  "project_iac_desc": "Implementación de infraestructura en la nube usando Terraform y AWS para despliegues automatizados.",
  "project_python_title": "Automatización con Python",
  "project_python_desc": "Creación de herramientas y scripts en Python para la gestión de recursos en la nube y la automatización de tareas.",
  "project_k8s_title": "Clúster de Kubernetes",
  "project_k8s_desc": "Configuración y gestión de un clúster de Kubernetes para aplicaciones en contenedores.",
  "project_monitoring_title": "Monitoreo de Sistemas",
  "project_monitoring_desc": "Stack Prometheus, Grafana y Alertmanager para infraestructura distribuida.",
  "about_page_title": "Sobre Mí - Víctor Araya",
  "about_main_title": "Mi Filosofía de Trabajo",
  "about_p1": "Soy Víctor Araya, padre de familia, un ingeniero de sistemas autodidacta enfocado en el ecosistema Cloud. Mi trayectoria en tecnología me ha enseñado una lección fundamental: los sistemas más robustos no son los que nunca fallan, sino los que están diseñados para ser resilientes, observables y capaces de recuperarse con rapidez.",
  "about_subtitle1": "Del \"Cómo\" al \"Porqué\"",
  "about_p2": "Mi pasión por DevOps nació de la curiosidad por ir más allá de la simple ejecución de tareas. En lugar de preguntar \"¿cómo despliego esta aplicación?\", comencé a preguntarme \"¿cómo construimos un sistema que permita despliegues seguros y automatizados, a cualquier hora y con mínima intervención humana?\".",
  "about_p3": "Esta pregunta me llevó a profundizar en los principios de la Infraestructura como Código (IaC), la entrega continua (CI/CD) y la observabilidad. Entiendo la tecnología no como un fin en sí misma, sino como un medio para alcanzar objetivos de negocio cruciales: agilidad, estabilidad y confianza.",
  "about_subtitle2": "Cultura de Mejora Continua",
  "about_p4": "Adopto una mentalidad de mejora iterativa en todo lo que hago. Creo firmemente que la automatización es la clave para liberar el potencial humano, permitiendo que los equipos se centren en la innovación en lugar de en la gestión de crisis. Para mí, un pipeline de CI/CD bien diseñado o un script de Terraform idempotente son más que simples herramientas; son la materialización de una cultura que valora la consistencia, la previsibilidad y la colaboración.",
  "about_back_button": "← Ir al inicio",
  "blog_fundamentos_title": "Fundamentos",
  "blog_fundamentos_excerpt": "Explorando los conceptos esenciales de Kubernetes y cómo aplicarlos en entornos de Site Reliability Engineering…",
  "blog_automatizacion_title": "Automatización",
  "blog_automatizacion_excerpt": "Cómo implementar infraestructura como código usando Terraform para gestionar recursos en múltiples nubes…",
  "blog_monitoreo_title": "Monitoreo",
  "blog_monitoreo_excerpt": "Configuración avanzada de Prometheus para monitoreo de sistemas distribuidos y estrategias de alerting efectivas…",
  "blog_read_more": "Leer más",
  "form_name": "Nombre",
  "form_email": "Email",
  "form_message": "Deja tu mensaje",
  "form_send": "Enviar",
  "form_success_message": "<div class='alert alert-success mb-0' role='alert'>¡Gracias! Tu mensaje fue enviado correctamente.</div>",
  "form_error_message": "<div class='alert alert-danger mb-0' role='alert'>No se pudo enviar. Intenta nuevamente más tarde.</div>",
  "footer_copyright": "© {year} Varaya Labs. Todos los derechos reservados.",
  "project_view_on_github": "Ver en GitHub",
  "post_published_on": "Publicado el ",
  "post_back_to_blog": "← Volver al blog",
  "post_automatizacion_title": "Automatización DevOps: De la Infraestructura al Despliegue",
  "post_automatizacion_body": "<p class='lead'>La automatización es el corazón que bombea la sangre en las venas de DevOps y SRE. Es el principio que nos permite construir sistemas consistentes, repetibles y escalables, liberándonos de tareas manuales propensas a errores.</p><h2 class='mt-4'>Infraestructura como Código (IaC): Los Cimientos</h2><p>Atrás quedaron los días de aprovisionar servidores manualmente a través de consolas web. Con IaC, definimos nuestra infraestructura (servidores, bases de datos, redes) en archivos de código. Mis principios al usar herramientas como Terraform son:</p><ul><li><strong>Modularización:</strong> No escribo un archivo gigante de Terraform para todo. Divido la infraestructura en módulos lógicos y reutilizables (ej: un módulo para la red, otro para la base de datos). Esto hace que el código sea más limpio y fácil de mantener.</li><li><strong>Reutilización:</strong> Gracias a los módulos, puedo crear un nuevo entorno completo (como staging o desarrollo) en minutos, sabiendo que será una réplica exacta de producción.</li><li><strong>Manejo de Estados Remotos:</strong> Terraform necesita un archivo de estado para saber qué infraestructura ha creado. Guardar este estado de forma remota (en un bucket de S3, por ejemplo) y con bloqueos es crucial para trabajar en equipo sin conflictos.</li></ul><p class='text-center'><img src='../../public/assets/automatizacion-1.png' class='img-fluid rounded my-3' alt='Esquema de Infraestructura como Código (IaC) con Terraform y AWS.'><small class='text-muted d-block mb-2'>Definiendo la nube con código versionado.</small></p><h2 class='mt-4'>Pipelines de CI/CD: La Línea de Ensamblaje</h2><p>Un pipeline de CI/CD es una línea de ensamblaje automatizada que lleva el código desde el repositorio hasta producción. Cada cambio dispara un proceso que yo estructuro en fases claras:</p><ol><li><strong>Build:</strong> Se compila el código y, más comúnmente hoy en día, se construye una imagen de contenedor (Docker). El resultado es un artefacto inmutable.</li><li><strong>Test:</strong> Se ejecutan pruebas automatizadas (unitarias, de integración) contra el artefacto recién creado para asegurar que no hemos roto nada.</li><li><strong>Seguridad:</strong> ¡La seguridad no es negociable! Integro herramientas de escaneo de vulnerabilidades (Trivy, Snyk) y de secretos (GitLeaks) para detectar problemas antes de que lleguen a producción (Shift-Left Security).</li><li><strong>Despliegue:</strong> Si todas las etapas anteriores (o gates de calidad) se superan, el pipeline despliega el artefacto en los diferentes entornos (Dev, Staging, Prod) usando estrategias seguras como Blue-Green o Canary.</li></ol><p class='text-center'><img src='../../public/assets/automatizacion-2.png' class='img-fluid rounded my-3' alt='Diagrama de un pipeline CI/CD con fases de Build, Test, Security y Deploy.'><small class='text-muted d-block mb-2'>El camino automatizado del código a producción.</small></p><h2 class='mt-4'>Operación Confiable: Despliegues a Prueba de Fallos</h2><p>Llegar a producción es solo la mitad del camino. La automatización también es clave para operar de forma fiable. Utilizo técnicas como los 'feature flags' para activar nuevas funcionalidades de forma gradual y segura, y tengo procesos de rollback automatizados para revertir un despliegue fallido en segundos, minimizando el impacto en los usuarios.</p>",
  "post_fundamentos_title": "Fundamentos SRE/DevOps: Conceptos Clave para Empezar",
  "post_fundamentos_body": "<p class='lead'>Todo gran viaje comienza con un primer paso, y en el mundo de DevOps y SRE, ese paso es comprender los conceptos fundamentales que sustentan todo lo demás.</p><h2 class='mt-4'>¿Qué Problema Resuelven Estas Metodologías?</h2><p>Históricamente, el desarrollo de software (Dev) y la operación de sistemas (Ops) vivían en mundos separados, a menudo con objetivos contrapuestos. Los desarrolladores quieren lanzar nuevas funcionalidades rápidamente, mientras que operaciones busca estabilidad. Esta fricción creaba silos, cuellos de botella y, en última instancia, retrasaba la entrega de valor.</p><p class='text-center'><img src='../../public/assets/fundamentos-1.png' class='img-fluid rounded my-3' alt='Esquema de silos entre Dev y Ops, y cómo DevOps los une.'><small class='text-muted d-block mb-2'>De silos aislados a equipos colaborativos.</small></p><h2 class='mt-4'>Conceptos Clave que Debes Dominar</h2><p>Para pensar como un ingeniero de SRE/DevOps, ciertos conceptos deben formar parte de tu ADN:</p><ul><li><strong>Declarativo vs. Imperativo:</strong> Imagina que quieres un café. El enfoque imperativo sería dar instrucciones paso a paso: 've a la cocina, toma la taza, abre el frasco, echa una cucharada...'. El enfoque declarativo es simplemente decir: 'quiero un café'. Tú declaras el estado final deseado, y la herramienta (como Terraform o Kubernetes) se encarga de los pasos para llegar allí.</li></ul><p class='text-center'><img src='../../public/assets/fundamentos-2.png' class='img-fluid rounded my-3' alt='Esquema comparando el enfoque declarativo e imperativo.'><small class='text-muted d-block mb-2'>Declaras el 'qué', no el 'cómo'.</small></p><ul><li><strong>Idempotencia:</strong> Es una propiedad crucial para la automatización segura. Significa que puedes ejecutar la misma operación una y otra vez, y el resultado siempre será el mismo. Aplicar un script de Terraform 10 veces no crea 10 infraestructuras; asegura que la infraestructura esté en el estado definido en el código.</li><li><strong>Inmutabilidad:</strong> Este concepto, aplicado a la infraestructura, significa: 'nunca modifiques un servidor en producción; reemplázalo'. Si necesitas actualizar una aplicación, no entras al servidor a cambiar archivos. En su lugar, creas una nueva versión de la imagen del servidor y la despliegas, desechando la antigua. Esto evita la 'deriva de configuración' y hace que los sistemas sean más predecibles.</li></ul><h2 class='mt-4'>Buenas Prácticas para Empezar con el Pie Derecho</h2><ul><li><strong>Versionar todo (GitOps):</strong> Tu código de aplicación ya está en Git, ¿verdad? Pues tu infraestructura (Terraform), tu configuración de pipeline (GitHub Actions) y tus manifiestos de Kubernetes también deberían estarlo. Git se convierte en la única fuente de verdad.</li><li><strong>Automatizar pruebas y despliegues (CI/CD):</strong> La Integración Continua (CI) y la Entrega Continua (CD) son el motor de DevOps. Cada cambio de código debe disparar un proceso automático que compile, pruebe y despliegue de forma segura.</li><li><strong>Observabilidad Mínima Viable:</strong> No puedes mejorar lo que no puedes medir. Desde el día uno, asegúrate de tener al menos los tres pilares de la observabilidad: <strong>Métricas</strong> (datos numéricos), <strong>Logs</strong> (eventos) y <strong>Traces</strong> (flujo de solicitudes).</li></ul><p class='text-center'><img src='../../public/assets/fundamentos-3.png' class='img-fluid rounded my-3' alt='Esquema de las tres patas de la observabilidad (Métricas, Logs, Traces).'><small class='text-muted d-block mb-2'>Los tres pilares para entender tu sistema.</small></p>",
  "post_monitoreo_title": "Monitoreo Accionable: Métricas, Alertas y Dashboards",
  "post_monitoreo_body": "<p class='lead'>El monitoreo no se trata de coleccionar datos y gráficos bonitos. Se trata de obtener visibilidad accionable sobre la salud de tus sistemas para poder tomar decisiones informadas, anticipar problemas y responder a incidentes de forma eficaz.</p><h2 class='mt-4'>Diseño de Métricas: La Calidad sobre la Cantidad</h2><p>Con Prometheus, la base de todo son las métricas y sus etiquetas. Un mal diseño aquí puede llevar a un sistema de monitoreo lento, caro y difícil de usar. Mis dos reglas de oro:</p><ul><li><strong>Cardinalidad Controlada:</strong> La cardinalidad es el número de series temporales únicas que una métrica genera. Se calcula por la combinación de etiquetas. Usar etiquetas con valores únicos para cada usuario o solicitud (como un `user_id` o `request_id`) es una receta para el desastre. Mantiene las etiquetas para dimensiones de baja cardinalidad: `endpoint`, `http_method`, `status_code`.</li><li><strong>Etiquetas que Aportan Contexto:</strong> Las etiquetas son superpoderes. Te permiten agregar, filtrar y segmentar datos. Una buena etiqueta te ayuda a pasar de 'la latencia es alta' a 'la latencia es alta para el método POST en el servicio de pagos'.</li></ul><p class='text-center'><img src='../../public/assets/monitoreo-1.png' class='img-fluid rounded my-3' alt='Esquema mostrando cómo las etiquetas de métricas afectan la cardinalidad en Prometheus.'><small class='text-muted d-block mb-2'>Etiquetas correctas para queries eficientes.</small></p><h2 class='mt-4'>Alertas Útiles: Menos Ruido, Más Señal</h2><p>El objetivo de las alertas no es avisar de 'algo está mal', sino de 'algo requiere tu atención AHORA'. Mi enfoque con Alertmanager se basa en reducir el ruido a toda costa:</p><ul><li><strong>Rutas y Receptores:</strong> No todas las alertas son iguales ni deben ir al mismo sitio. Las alertas críticas (`severity=critical`) pueden ir a PagerDuty y a un canal de Slack ruidoso. Las advertencias (`severity=warning`) pueden ir solo a Slack, y las informativas a un correo.</li><li><strong>Severidades Claras:</strong> Clasifico las alertas en niveles de severidad (`critical`, `warning`, `info`) para que el equipo sepa qué requiere una acción inmediata y qué puede esperar.</li><li><strong>Agrupación y Silencios:</strong> Si 50 servidores de un clúster tienen el mismo problema, no quieres 50 alertas. Alertmanager agrupa estas alertas por etiquetas (`cluster`, `service`) en una sola notificación. Además, permite crear 'silencios' para suprimir alertas durante mantenimientos planificados.</li></ul><p class='text-center'><img src='../../public/assets/monitoreo-2.png' class='img-fluid rounded my-3' alt='Diagrama de flujo de Alertmanager: cómo agrupa y enruta las alertas.'><small class='text-muted d-block mb-2'>Enrutando la alerta correcta a la persona correcta.</small></p><h2 class='mt-4'>Dashboards que Sirven: Contando una Historia</h2><p>Un dashboard de Grafana no debe ser un cementerio de gráficos. Debe contar una historia clara y guiar al usuario desde una vista de alto nivel (¿está todo bien?) hasta los detalles específicos para diagnosticar un problema. Suelo estructurarlos usando el método RED (Rate, Errors, Duration) o USE (Utilization, Saturation, Errors) para tener una visión estandarizada de la salud de los servicios.</p>"
}
